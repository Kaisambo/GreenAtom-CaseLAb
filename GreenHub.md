# <span style="color:#3362d6">_Теоретическое описание решения поставленной задачи_</span>
## Теоретическое определение бинарного дерева: 

Бинарное дерево или двоичное дерево — это дерево, в котором у каждого из его узлов не более двух дочерних узлов. При этом каждый дочерний узел тоже представляет собой бинарное дерево.
Благодаря тому, что дочерних узлов всегда не больше двух, их называют правый и левый дочерние узлы.
Есть завершенное и полное деревья. Для бинарных деревьев они приобретают следующий вид:
Завершенное бинарное дерево — это бинарное дерево, в котором каждый уровень, кроме последнего, полностью заполнен, а заполнение последнего уровня производится слева направо
Полное бинарное дерево — это бинарное дерево, в котором у каждого узла ноль или два дочерних узла.

### Пример бинарного дерева:
# ![StateTree.png](StateTree.png)
В данном примере бинарное дерево содержит числа от 2 до 30. Корень дерева - узел со значением 10. Левый потомок корня имеет значение 3, а его правый потомок - значение 12. Узлы дальше разветвляются, так что у левого потомка 3 есть потомки 2 и 4, а у правого потомка 12 - потомки 11 и 30.

Бинарное дерево имеет несколько основных операций, которые позволяют работать с ним:
Вставка – добавление нового узла в дерево. Новый узел может быть добавлен как левым, так и правым потомком существующего узла, в зависимости от условий, которые задаются при выполнении операции вставки.
Удаление – удаление узла из дерева. При удалении узла, его потомки (если они существуют) становятся потомками его родителя.
Поиск – поиск узла в дереве. Поиск может быть реализован как рекурсивным, так и итеративным способом.
Обход – обход дерева с целью выполнения определенных операций над его узлами. В зависимости от порядка обхода, результат операции может быть различным.

Бинарные деревья широко применяются в алгоритмах, таких как поиск, сортировка и обход графа. В различных задачах бинарное дерево может быть использовано для эффективного хранения и обработки данных.

Одним из наиболее часто используемых типов бинарного дерева является двоичное дерево поиска (Binary Search Tree, BST). В этом типе деревьев каждый узел содержит значение, которое является уникальным ключом для поиска и сортировки элементов. Узлы в BST располагаются таким образом, чтобы ключи слева от узла были меньше его значения, а справа – больше.

Бинарные деревья являются эффективными структурами данных, так как время выполнения операций (вставка, удаление, поиск) в них обычно пропорционально высоте дерева, а не числу узлов. Однако, в худшем случае, дерево может быть несбалансированным и иметь высоту, равную числу узлов, что может существенно снизить эффективность операций.

В заключении, бинарное дерево – это важная структура данных, которая находит применение во многих областях программирования и алгоритмов. Знание работы с ним позволяет разработчикам эффективно решать различные задачи, связанные с хранением и обработкой данных.
# <span style="color:#3362d6">_Алгоритм реализации поставленной задачи_</span>

_Для выполнения поставленной задачи необходимо разработать алгоритм по ее реализации. Данный алгоритм состоит из следующих пунктов:_

1. Описание класса элемента бинарного дерева;
2. Описание класса бинарного дерева;
3. Реализация методов поиска, добавления и вывода бинарного дерева;
4. Реализация функции поиска ближайших статей с большим номером со следующими условиями:
   1. Описание функции поиска заданной статьи;
   2. Проверка условий наличия статьи-родителя и сравнение значений текущей статьи и статьи родителя;
   3. Проверка наличия статьи-родителя и наличия правого потомка;
   4. Сравнение значений текущей статьи с правым потомком, либо сравнение значений текущей статьи со значением статьи-родителя и проверка наличия правого потомка;
   5. Проверка наличия правого потомка и сравнение значения текущей статьи со значением статьи-родителя;
   6. Описание цикла While с условием наличия статьи-родителя и сравнения значений статьи-родителя с заданным ключом;
5. Заполнение дерева значениями;
6. Вызов функции по нахождению статьи;
7. Вывод полученного значения.

# <span style="color:#3362d6">_Листинг кода программы, реализующей поставленную задачу на языке C++_</span>

~~~shell 
#include <iostream>
#include <iomanip>
#include <windows.h>
#include <vector>
#include <string>

using namespace std;

class Item {
public:
    int data;
    Item* parent;
    Item* left_child;
    Item* right_child;

    Item(int val) {
        parent = NULL;
        left_child = NULL;
        right_child = NULL;
        data = val;
    }
};

class BinaryTree {
private:
    Item* root;
    int TreeSize;
    void print_tree(Item*);
    void delete_tree(Item*);
public:
    BinaryTree(int);
    ~BinaryTree();
    void print();
    void print_tree(Item*, int);
    void insert(int);
    void GreenFunc(int);
   
};

BinaryTree::BinaryTree(int key)
{
    root = new Item(key);
    TreeSize = 1;
}

BinaryTree::~BinaryTree()
{
    delete(root);
}

void BinaryTree::print()
{
    print_tree(root);
    cout << endl;
}

void BinaryTree::print_tree(Item* curr)
{
    if (curr) 
    {
        print_tree(curr->left_child);
        cout << " data - " << curr->data << " ";
        print_tree(curr->right_child);
    }
}

void BinaryTree::insert(int key)
{
    Item* curr = root;
    while (curr && curr->data != key)
    {
        if (curr->data > key && curr->left_child == NULL)
        {
            curr->left_child = new Item(key);
            curr->left_child->parent = curr;
            ++TreeSize;
            return;
        }
        if (curr->data < key && curr->right_child == NULL)
        {
            curr->right_child = new Item(key);
            curr->right_child->parent = curr;
            ++TreeSize;
            return;
        }
        if (curr->data > key) {
            curr->left_child->parent = curr;
            curr = curr->left_child;
        }
        else {
            curr->right_child->parent = curr;
            curr = curr->right_child;
        }
           
    }
}

void BinaryTree::GreenFunc(int key) {
    Item* curr = root;
    while (curr && curr->data != key)
    {
        if (curr->data > key) {
            curr->left_child->parent = curr;
            curr = curr->left_child;
        }   
        else {
            curr->right_child->parent = curr;
            curr = curr->right_child;
        }
    }
    if (curr->parent != NULL && curr->data < curr->parent->data  ) {
        cout << curr->parent->data << endl;
    }
    else if (curr->parent == nullptr && curr->right_child) {
        cout << curr->right_child->data << endl;
    }
    else if (curr->right_child > curr || curr->data > curr->parent->data && curr->right_child) {
        cout << curr->right_child->data << endl;
    }
    else if (!curr->right_child && curr->data > curr->parent->data ) {
            while (curr->parent != nullptr && curr->parent->data < key ) {
                if (curr->parent) {
                    curr = curr->parent;
                }
            }
            if (curr->parent == nullptr) {
                cout << "This item do not have biggest number" << endl;
            }
            else {
                cout << curr->parent->data << endl;;
            }
    }
    else {
        cout << "This item do not have biggest number" << endl;;
    }
}

int main() {
    int insert = 0;

    BinaryTree Tree1(10);
    
    Tree1.insert(3);
    Tree1.insert(2);
    Tree1.insert(12);
    Tree1.insert(4);
    Tree1.insert(5);
    Tree1.insert(11);
    Tree1.insert(30);
    
    cout << "Please enter the number for search:" << endl;
    cin >> insert;
    cout << endl;
    cout << "Nearest item with bigger number - ";
    Tree1.GreenFunc(insert);
    system("PAUSE");
}

~~~

# <span style="color:#3362d6">_Техническое задание для передачи сторонней организации_</span>



### Название проекта: Алгоритм для поиска ближайшей статьи с большим номером

_Цель проекта:_  Разработка программы для автоматизированного поиска ближайшей статьи затрат предприятия с большим номером.

В отделе бухгалтерского и налогового учета в настоящее время ведется разработка нового блока отчетов, который будет автоматически находить ближайшую статью затрат с более высоким номером, относительно указанной статьи. Это значит, что система будет искать статью, которая следует за указанной статьей в иерархии статей затрат. Статьи затрат в данной системе пронумерованы и организованы в виде иерархии, где каждая статья имеет ссылку на статью-родителя и может иметь одну или несколько статей-потомков. Такая структура помогает упорядочить и классифицировать затраты в системе учета.

_Функциональные требования:_

Напишем программу, которая будет выполнять поиск ближайшей статьи затрат с большим номером, и выводить этот номер. Пользователь будет вводить номер статьи затрат, и программа будет искать ближайшую к нему статью с большим номером.
Программа будет искать ближайшую к указанной статью с большим номером. Если найдена статья с большим номером, программа выведет ее номер. В противном случае, программа выведет сообщение о том, что статьи с большим номером не существует.
Нефункциональные требования:

Программа должна быть написана на языке программирования C++.
Входные данные должны быть представлены в виде файла или базы данных.
Программа должна иметь удобный и интуитивно понятный интерфейс.
Программа должна работать быстро и эффективно для любого размера входных данных.
Программа должна быть простой в использовании и обладать высокой надежностью.
	
_Системные требования:_

Операционная система: любая поддерживаемая C++.
Программа должна быть совместима с C++ версии 9 или выше.
План работы:

_Изучение и анализ поставленной задачи._
Проектирование алгоритма для поиска ближайшей статьи с большим номером.
Разработка программы на языке C++.
Тестирование программы на различных входных данных.
Оформление результата работы в виде документации.
Контрольные точки и сроки выполнения:

_Контрольная точка 1:_ Завершение проектирования алгоритма - через 1 неделю.

_Контрольная точка 2:_ Завершение разработки программы - через 2 недели.

_Контрольная точка 3:_ Завершение тестирования программы - через 3 недели.

_Контрольная точка 4:_ Завершение оформления документации - через 4 недели.

_Ожидаемые результаты:_

Разработанная программа, выполняющая поиск ближайшей статьи с большим номером.
Документация, описывающая использование программы и ее функциональность.

### Благодарю за внимание и оценку!



